{"application":{"id":"3","applicationInfo":{"name":"application"},"applicationContent":{"applicationContributions":{"ur-mounting":{"type":"ur-mounting","version":"0.0.1","mounting":{"baseAngle":{"value":0,"unit":"deg"},"tiltAngle":{"value":0,"unit":"deg"}}},"ur-frames":{"type":"ur-frames","version":"0.0.5","framesList":[{"name":"base","nameVariable":{"name":"base","reference":false,"type":"$$Variable","valueType":"frame"},"parent":"world","pose":{"position":[0,0,0],"orientation":[0,0,0]}},{"name":"tcp","nameVariable":{"name":"tcp","reference":false,"type":"$$Variable","valueType":"frame"},"parent":"base","pose":{"position":[0,0,0],"orientation":[0,0,0]}},{"name":"world","nameVariable":{"name":"world","reference":false,"type":"$$Variable","valueType":"frame"},"pose":{"position":[0,0,0],"orientation":[0,0,0]}}]},"ur-grid-pattern":{"type":"ur-grid-pattern","version":"0.0.3","grids":[{"grid":{"name":"grid","reference":false,"type":"$$Variable","valueType":"grid"},"waypoint":{"name":"grid_iterator","reference":false,"type":"$$Variable","valueType":"waypoint"},"corners":[null,null,null,null],"numRows":4,"numColumns":5}]},"ur-end-effector":{"type":"ur-end-effector","version":"0.0.2","endEffectors":[{"id":"39c19fcf-2673-d4e7-b1dc-78866c65f35f","name":"Robot","payload":{"weight":{"value":0,"unit":"kg"}},"cog":{"cx":{"value":0,"unit":"m"},"cy":{"value":0,"unit":"m"},"cz":{"value":0,"unit":"m"}},"inertia":{"Ixx":{"value":0,"unit":"kg*m^2"},"Iyy":{"value":0,"unit":"kg*m^2"},"Izz":{"value":0,"unit":"kg*m^2"},"Ixy":{"value":0,"unit":"kg*m^2"},"Ixz":{"value":0,"unit":"kg*m^2"},"Iyz":{"value":0,"unit":"kg*m^2"}},"useCustomInertia":false,"tcps":[{"id":"67b595b4-9a65-e62a-c12c-e957e52f288e","name":"Tool_flange","x":{"value":0,"unit":"m"},"y":{"value":0,"unit":"m"},"z":{"value":0,"unit":"m"},"rx":{"value":0,"unit":"rad"},"ry":{"value":0,"unit":"rad"},"rz":{"value":0,"unit":"rad"}}]}],"defaultTcp":{"endEffectorId":"39c19fcf-2673-d4e7-b1dc-78866c65f35f","tcpId":"67b595b4-9a65-e62a-c12c-e957e52f288e"}},"ur-smart-skills":{"type":"ur-smart-skills","version":"0.0.2","preamble":"# Start of Forces\n###\n# Transforms the force and torque values along the axes of the given pose\n# @param pose pose Any valid pose, defaults to base, the x, y, and z values are ignored\n# @return array 6D force torque vector with [Fx, Fy, Fz, Mx, My, Mz] aligned to pose in N and Nm respectively\n###\ndef get_tcp_wrench_in_frame(pose = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]):\n    # we are only interested in the rotation of pose, set translations to zero\n    local target_pose = pose\n    target_pose[0] = 0\n    target_pose[1] = 0\n    target_pose[2] = 0\n    # the conversion needs to happen as poses, so we need to convert back and forth a bit\n    local force = get_tcp_force()\n    local force_vector_as_pose = p[force[0], force[1], force[2], 0, 0, 0]\n    local torque_vector_as_pose = p[force[3], force[4], force[5], 0, 0, 0]\n    local transformed_force_as_pose = pose_trans(pose_inv(target_pose), force_vector_as_pose)\n    local transformed_torque_as_pose = pose_trans(pose_inv(target_pose), torque_vector_as_pose)\n    return [transformed_force_as_pose[0], transformed_force_as_pose[1], transformed_force_as_pose[2], transformed_torque_as_pose[0], transformed_torque_as_pose[1], transformed_torque_as_pose[2]]\nend\n###\n# See documentation for @link:get_tcp_wrench_in_frame()\n# @return forces and torques measured in TCP frame\n###\ndef get_tcp_wrench():\n    return get_tcp_wrench_in_frame(get_target_tcp_pose())\nend\n###\n# Projects the measured TCP force along the axis given\n# @param axis array 3D vector\n###\ndef project_tcp_force(axis):\n    local wrench = get_tcp_wrench()\n    local force = [wrench[0], wrench[1], wrench[2]]\n    return dot(force, axis)\nend\n# End of Forces\n# Start of Math\n# Definitions of constants\nglobal PI = acos(-1)\n###\n# Calculates the cross product between to 3D vectors\n# @param v1 array 3D vector\n# @param v2 array 3D vector\n###\ndef cross(v1, v2):\n    if length(v1) != length(v2):\n        popup(str_cat(\"For computing the cross product, the two vectors must have the same length. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    if length(v1) != 3:\n        popup(str_cat(\"For computing the cross product, the two vectors must have length 3. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    cross = [0.0, 0.0, 0.0]\n    i = 0\n    while i < 3:\n        j = (i + 1) % 3 # The next index in a cyclic order\n        k = (i + 2) % 3 # The next next index in a cyclic order\n        cross[i] = v1[j] * v2[k] - v1[k] * v2[j]\n        i = i + 1\n    end\n    return cross\nend\n###\n# Calculates the dot product between to n-dimensional vectors\n# @param v1 array nD vector\n# @param v2 array nD vector\n###\ndef dot(v1, v2):\n    if length(v1) != length(v2):\n        popup(str_cat(\"For computing the dot product, the two vectors must have the same length. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    result = 0\n    i = 0\n    while i < length(v1):\n        result = result + (v1[i] * v2[i])\n        i = i + 1\n    end\n    return result\nend\n###\n# Return the larger number of a and b\n# @param a number a\n# @param b number b\n###\ndef max(a, b):\n    if a > b:\n        return a\n    end\n    return b\nend\n# End of Math\n# Start of Move Helper\nur_move_until_force_distance = 0.1\nur_move_until_force_direction = [0, 0, 1]\nur_move_until_force_velocity = 0.1\nur_move_until_force_acceleration = 0.2\ndef ur_move_tcp_direction(distance, direction, velocity, acceleration, blend_radius):\n    current_pose = get_target_tcp_pose()\n    movement = normalize(direction) * distance\n    target_pose = pose_trans(current_pose, p[movement[0], movement[1], movement[2], 0, 0, 0])\n    movel(target_pose, a = 0.2, v = velocity, r = blend_radius)\nend\nthread ur_move_until_force_thread():\n    ur_move_tcp_direction(ur_move_until_force_distance, ur_move_until_force_direction, ur_move_until_force_velocity, ur_move_until_force_acceleration, 0)\n    popup(\"No contact detected.\", title = \"No Contact\", warning = False, error = True, blocking = False)\n    halt\nend\n###\n# Moves the robot in the TCP direction specified until a contact point is reached *or*\n# the robot reaches the maximum distance allowed specified by the distance parameter.\n# @param distance number The maximum distance the robot is allowed to travel in the direction specified\n# @param direction array 3D vector determining the move direction of the TCP\n# @param velocity number Velocity of the robot\n# @param acceleration number Acceleration of the robot\n# @param stop_force number Maximum search radius\n###\ndef ur_move_until_force(distance = 0.1, direction = [0, 0, 1], velocity = 0.1, acceleration = 0.2, stop_force = 20):\n    ur_move_until_force_distance = distance\n    ur_move_until_force_direction = direction\n    ur_move_until_force_velocity = velocity\n    ur_move_until_force_acceleration = acceleration\n    \n    thrd = run ur_move_until_force_thread()\n    while - project_tcp_force(direction) < stop_force:\n        sync()\n    end\n    kill thrd\n    actual_pose = get_actual_tcp_pose()\n    stopl(1.0)\n    return actual_pose\nend\ndef ur_path_move(end_q, v, rampdown=False):\n    # Calculate distance to target\n    delta_q = end_q - get_target_joint_positions()\n    # Calculate time to move based on desired velocity\n    t = norm(delta_q) / v\n    if(rampdown):\n        while(norm(get_target_joint_speeds()) > 0.0001):\n            servoj(end_q , 0, 0, max(t, 0.001))\n        end\n    else:\n        servoj(end_q , 0, 0, t, lookahead_time=0.1,  gain=2000)\n    end\nend\n# End of Move Helper"},"ur-dashboard-frontend-dashboard-application":{"type":"ur-dashboard-frontend-dashboard-application","version":"1.0.0","ipAddress":"10.55.1.189"},"ur-er-calib-studio-frontend-calib-application":{"type":"ur-er-calib-studio-frontend-calib-application","version":"1.0.0","ipAddress":"192.168.0.124"}},"sourceConfig":{"labelMap":{},"analogDomainMap":{},"presets":{}},"sourcesNodes":{"robot":{"groupId":"robot","version":"1.0.0.","sources":[{"sourceID":"ur-wired-io","signals":[{"signalID":"DI 0","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 1","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 2","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 3","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 4","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 5","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 6","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 7","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DO 0","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 1","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 2","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 3","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 4","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 5","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 6","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 7","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CI 0","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 1","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 2","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 3","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 4","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 5","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 6","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CI 7","direction":"IN","valueType":"BOOLEAN"},{"signalID":"CO 0","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 1","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 2","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 3","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 4","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 5","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 6","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"CO 7","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"AI 0","direction":"IN","valueType":"FLOAT"},{"signalID":"AI 1","direction":"IN","valueType":"FLOAT"},{"signalID":"AO 0","direction":"OUT","valueType":"FLOAT"},{"signalID":"AO 1","direction":"OUT","valueType":"FLOAT"}],"webSocketURL":"/sources/wired-io"},{"sourceID":"ur-tool-io","signals":[{"signalID":"DI 0","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DI 1","direction":"IN","valueType":"BOOLEAN"},{"signalID":"DO 0","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"DO 1","direction":"OUT","valueType":"BOOLEAN"},{"signalID":"AI 0","direction":"IN","valueType":"FLOAT"},{"signalID":"AI 1","direction":"IN","valueType":"FLOAT"}],"webSocketURL":"/sources/tool-io"}],"isDynamic":false},"ur-modbus":{"groupId":"ur-modbus","isDynamic":true,"version":"1.0.0","sources":[]},"universalrobots-ethernetip-frontend-ethernetip":{"type":"universalrobots-ethernetip-frontend-ethernetip","version":"1.0.0","programAction":"IGNORE","enabled":false,"groupId":"universalrobots-ethernetip-frontend-ethernetip","sources":[{"sourceID":"ur-ethernetip-source","name":"Ethernet IP","signals":[]}],"isDynamic":false}},"safety":{"settings":{"io":{"automaticModeSafeguardResetInput":{"name":"automaticModeSafeguardResetInput","valueA":255,"valueB":255},"automaticModeSafeguardStopInput":{"name":"automaticModeSafeguardStopInput","valueA":255,"valueB":255},"emergencyStopInput":{"name":"emergencyStopInput","valueA":255,"valueB":255},"notReducedModeOutput":{"name":"notReducedModeOutput","ossdEnabled":false,"valueA":255,"valueB":255},"operationalModeInput":{"name":"operationalModeInput","valueA":255,"valueB":255},"reducedModeInput":{"name":"reducedModeInput","valueA":255,"valueB":255},"reducedModeOutput":{"name":"reducedModeOutput","ossdEnabled":false,"valueA":255,"valueB":255},"robotMovingOutput":{"name":"robotMovingOutput","ossdEnabled":false,"valueA":255,"valueB":255},"robotNotStoppingOutput":{"name":"robotNotStoppingOutput","ossdEnabled":false,"valueA":255,"valueB":255},"safeHomeOutput":{"name":"safeHomeOutput","ossdEnabled":false,"valueA":255,"valueB":255},"safeguardResetInput":{"name":"safeguardResetInput","valueA":0,"valueB":1},"systemEmergencyStoppedOutput":{"name":"systemEmergencyStoppedOutput","ossdEnabled":false,"valueA":255,"valueB":255},"threePositionSwitchInput":{"name":"threePositionSwitchInput","valueA":255,"valueB":255}},"major":5,"minor":5,"normalJointPositions":{"base":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"elbow":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"shoulder":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist1":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist2":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist3":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false}},"normalJointSpeeds":{"base":3.3415926,"shoulder":3.3415926,"elbow":3.3415926,"wrist1":3.3415926,"wrist2":3.3415926,"wrist3":3.3415926},"normalRobotLimits":{"elbowForce":150,"elbowSpeed":1.5,"momentum":25,"power":300,"stoppingDistance":0.5,"stoppingTime":0.4,"toolForce":150,"toolSpeed":1.5},"reducedJointPositions":{"base":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"elbow":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"shoulder":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist1":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist2":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false},"wrist3":{"maximum":6.33555,"maximumJointPosition":0.05235988,"maximumRevolutionCounter":1,"minimum":-6.33555,"minimumJointPosition":6.2308254,"minimumRevolutionCounter":-2,"unlimited":false}},"reducedJointSpeeds":{"base":3.3415926,"shoulder":3.3415926,"elbow":3.3415926,"wrist1":3.3415926,"wrist2":3.3415926,"wrist3":3.3415926},"reducedRobotLimits":{"elbowForce":120,"elbowSpeed":0.75,"momentum":10,"power":200,"stoppingDistance":0.3,"stoppingTime":0.3,"toolForce":120,"toolSpeed":0.75},"safetyHardware":{"injectionMoldingMachineInterface":"NONE","teachPendant":"NORMAL"},"safetyPlanes":{"planes":[{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"},{"safetyPlane":{"name":"UNDEFINED","normalModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModePlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"reducedModeTriggerPlane":{"distance":0,"emptyPlane":true,"vector":{"x":0,"y":0,"z":0}},"restrictsElbow":false},"tilt":0,"offset":0,"rotation":0,"restriction":"disabled"}]},"safetySafeHome":{"base":-1,"elbow":-1,"shoulder":-1,"wrist1":-1,"wrist2":-1,"wrist3":-1},"threePosition":{"allowManualHighSpeed":true,"useTeachPendantAs3PE":false},"toolDirection":{"limitDeviation":6.2831855,"limitDirection":{"x":0,"y":0,"z":1},"limitRestriction":"DISABLED","toolPan":0,"toolTilt":0},"toolPositions":{"toolPositions":[{"center":{"x":0,"y":0,"z":0},"name":"UNDEFINED","radius":0},{"center":{"x":0,"y":0,"z":0},"name":"UNDEFINED","radius":0},{"center":{"x":0,"y":0,"z":0},"name":"UNDEFINED","radius":0}]}},"crc":"1475618907"},"operatorScreens":[],"smartSkills":[{"name":"Align to Plane","enabled":true,"type":"ur-align-to-plane","parameters":{"radius":0.05,"push_force":20,"n_plane_points":3,"max_distance":0.25,"velocity_slow":0.001,"velocity_search":0.035,"velocity_move":0.1,"acceleration":0.1}},{"name":"Align Z to Nearest Axis","enabled":true,"type":"ur-align-z-to-nearest-axis"},{"name":"Center","enabled":true,"type":"ur-center","parameters":{"push_force":10,"velocity_move":0.05,"acc_move":0.2,"max_radius_search":0.05,"num_fingers":3}},{"name":"Freedrive","enabled":true,"type":"ur-freedrive"},{"name":"Move into Contact","enabled":true,"type":"ur-move-into-contact","parameters":{"force":10,"velocity":0.05,"acceleration":0.2,"max_distance":0.25,"retract":0}},{"name":"Retract","enabled":true,"type":"ur-retract","parameters":{"distance":-0.1,"acceleration":0.4,"velocity":0.1}},{"name":"Custom Smart Skill","enabled":false,"type":"ur-custom-smart-skill","parameters":{}}]},"urscript":{"script":"set_safety_mode_transition_hardness(1)\nreset_world_model()\nset_input_actions_to_default()\nset_analog_outputdomain(0,1)\nset_analog_outputdomain(1,1)\nset_standard_analog_input_domain(0,1)\nset_standard_analog_input_domain(1,1)\nset_tool_voltage(12)\nset_tool_analog_input_domain(0,1)\nset_tool_analog_input_domain(1,1)\nset_gravity([0, 0, 9.82])\nmove_frame(\"base\", p[0, 0, 0, 0, 0, 0], \"world\")\nglobal base = \"base\"\nglobal tcp = \"tcp\"\nglobal world = \"world\"\nset_target_payload(0, [0, 0, 0], [0, 0, 0, 0, 0, 0])\nset_tcp(p[0, 0, 0, 0, 0, 0], \"Tool_flange\")\n# Start of Forces\n###\n# Transforms the force and torque values along the axes of the given pose\n# @param pose pose Any valid pose, defaults to base, the x, y, and z values are ignored\n# @return array 6D force torque vector with [Fx, Fy, Fz, Mx, My, Mz] aligned to pose in N and Nm respectively\n###\ndef get_tcp_wrench_in_frame(pose = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]):\n    # we are only interested in the rotation of pose, set translations to zero\n    local target_pose = pose\n    target_pose[0] = 0\n    target_pose[1] = 0\n    target_pose[2] = 0\n    # the conversion needs to happen as poses, so we need to convert back and forth a bit\n    local force = get_tcp_force()\n    local force_vector_as_pose = p[force[0], force[1], force[2], 0, 0, 0]\n    local torque_vector_as_pose = p[force[3], force[4], force[5], 0, 0, 0]\n    local transformed_force_as_pose = pose_trans(pose_inv(target_pose), force_vector_as_pose)\n    local transformed_torque_as_pose = pose_trans(pose_inv(target_pose), torque_vector_as_pose)\n    return [transformed_force_as_pose[0], transformed_force_as_pose[1], transformed_force_as_pose[2], transformed_torque_as_pose[0], transformed_torque_as_pose[1], transformed_torque_as_pose[2]]\nend\n###\n# See documentation for @link:get_tcp_wrench_in_frame()\n# @return forces and torques measured in TCP frame\n###\ndef get_tcp_wrench():\n    return get_tcp_wrench_in_frame(get_target_tcp_pose())\nend\n###\n# Projects the measured TCP force along the axis given\n# @param axis array 3D vector\n###\ndef project_tcp_force(axis):\n    local wrench = get_tcp_wrench()\n    local force = [wrench[0], wrench[1], wrench[2]]\n    return dot(force, axis)\nend\n# End of Forces\n# Start of Math\n# Definitions of constants\nglobal PI = acos(-1)\n###\n# Calculates the cross product between to 3D vectors\n# @param v1 array 3D vector\n# @param v2 array 3D vector\n###\ndef cross(v1, v2):\n    if length(v1) != length(v2):\n        popup(str_cat(\"For computing the cross product, the two vectors must have the same length. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    if length(v1) != 3:\n        popup(str_cat(\"For computing the cross product, the two vectors must have length 3. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    cross = [0.0, 0.0, 0.0]\n    i = 0\n    while i < 3:\n        j = (i + 1) % 3 # The next index in a cyclic order\n        k = (i + 2) % 3 # The next next index in a cyclic order\n        cross[i] = v1[j] * v2[k] - v1[k] * v2[j]\n        i = i + 1\n    end\n    return cross\nend\n###\n# Calculates the dot product between to n-dimensional vectors\n# @param v1 array nD vector\n# @param v2 array nD vector\n###\ndef dot(v1, v2):\n    if length(v1) != length(v2):\n        popup(str_cat(\"For computing the dot product, the two vectors must have the same length. Provided lengths: \", [length(v1), length(v2)]), error=True, blocking=True)\n        return -1\n    end\n    result = 0\n    i = 0\n    while i < length(v1):\n        result = result + (v1[i] * v2[i])\n        i = i + 1\n    end\n    return result\nend\n###\n# Return the larger number of a and b\n# @param a number a\n# @param b number b\n###\ndef max(a, b):\n    if a > b:\n        return a\n    end\n    return b\nend\n# End of Math\n# Start of Move Helper\nur_move_until_force_distance = 0.1\nur_move_until_force_direction = [0, 0, 1]\nur_move_until_force_velocity = 0.1\nur_move_until_force_acceleration = 0.2\ndef ur_move_tcp_direction(distance, direction, velocity, acceleration, blend_radius):\n    current_pose = get_target_tcp_pose()\n    movement = normalize(direction) * distance\n    target_pose = pose_trans(current_pose, p[movement[0], movement[1], movement[2], 0, 0, 0])\n    movel(target_pose, a = 0.2, v = velocity, r = blend_radius)\nend\nthread ur_move_until_force_thread():\n    ur_move_tcp_direction(ur_move_until_force_distance, ur_move_until_force_direction, ur_move_until_force_velocity, ur_move_until_force_acceleration, 0)\n    popup(\"No contact detected.\", title = \"No Contact\", warning = False, error = True, blocking = False)\n    halt\nend\n###\n# Moves the robot in the TCP direction specified until a contact point is reached *or*\n# the robot reaches the maximum distance allowed specified by the distance parameter.\n# @param distance number The maximum distance the robot is allowed to travel in the direction specified\n# @param direction array 3D vector determining the move direction of the TCP\n# @param velocity number Velocity of the robot\n# @param acceleration number Acceleration of the robot\n# @param stop_force number Maximum search radius\n###\ndef ur_move_until_force(distance = 0.1, direction = [0, 0, 1], velocity = 0.1, acceleration = 0.2, stop_force = 20):\n    ur_move_until_force_distance = distance\n    ur_move_until_force_direction = direction\n    ur_move_until_force_velocity = velocity\n    ur_move_until_force_acceleration = acceleration\n    \n    thrd = run ur_move_until_force_thread()\n    while - project_tcp_force(direction) < stop_force:\n        sync()\n    end\n    kill thrd\n    actual_pose = get_actual_tcp_pose()\n    stopl(1.0)\n    return actual_pose\nend\ndef ur_path_move(end_q, v, rampdown=False):\n    # Calculate distance to target\n    delta_q = end_q - get_target_joint_positions()\n    # Calculate time to move based on desired velocity\n    t = norm(delta_q) / v\n    if(rampdown):\n        while(norm(get_target_joint_speeds()) > 0.0001):\n            servoj(end_q , 0, 0, max(t, 0.001))\n        end\n    else:\n        servoj(end_q , 0, 0, t, lookahead_time=0.1,  gain=2000)\n    end\nend\n# End of Move Helper\nglobal ARK_ROS2Namespace = \"/IP010055001025\"\n# Define a struct type for errors\ndef ArkError(error_val):\n    return struct(error=error_val, message=\"\")\nend\n# init ros pubsub\ndef ark_init():\n    global rosser_start_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/trigger_detection\", \"ur_ark_ros_common_msgs/srv/TriggerDetection\")\n    sleep(0.5)\n    global rosser_wait_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/wait_detection\", \"ur_ark_ros_common_msgs/srv/WaitDetection\")\n    sleep(0.5)\n    global rosser_pub_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/publish_transform\", \"ur_ark_ros_common_msgs/srv/PublishTransform\")\n    sleep(0.5)\n    global rosser_settf_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/set_transformur\", \"ur_ark_ros_common_msgs/srv/SetTransformUR\")\n    sleep(0.5)\n    global rosser_gettf_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/get_transformur\", \"ur_ark_ros_common_msgs/srv/GetTransformUR\")\n    sleep(0.5)\n    global rosser_load_model_class_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/load_model\", \"ur_ark_ros_common_msgs/srv/LoadModel\")\n    sleep(0.5)\n    global rosser_classify_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/infer_classification\", \"ur_ark_ros_common_msgs/srv/InferClassification\")\n    sleep(0.5)\n    global rosser_pipeline_handle = ros_service_client_factory(ARK_ROS2Namespace + \"/pipeline_tag\", \"ur_ark_ros_common_msgs/srv/PipelineTag\")\n    sleep(0.5)\n    return ArkError(False)\nend\ndef ark_close():\n    rosser_start_handle.close()\n    sleep(0.5)\n    rosser_wait_handle.close()\n    sleep(0.5)\n    rosser_pub_handle.close()\n    sleep(0.5)\n    rosser_settf_handle.close()\n    sleep(0.5)\n    rosser_load_model_class_handle.close()\n    sleep(0.5)\n    rosser_classify_handle.close()\n    sleep(0.5)\n    rosser_pipeline_handle.close()\n    sleep(0.5)\n    return ArkError(False)\nend\n# detect tag\ndef ark_detect_tags(): \n    local i=0\n    while i < 10: \n      rosser_pipeline_handle.call(struct(pipeline_type=\"tag\"))\n      sleep(.1)\n      i = i + 1\n    end\n    return struct(error=ArkError(False))\nend\n \n# load classification model \ndef ark_load_classification_model(model):\n    model_path = str_cat(\"/workspaces/isaac_ros-dev/data/models/\", model)\n    rosser_load_model_class_handle.call(struct(model_filename=model_path, min_confidence=1.0, roi=struct(x=240.0, y=140.0, width=160.0, height=120.0)))\n    return ArkError(False)\nend  \ndef ark_set_classification_params(roi=struct(x=240.0, y=140.0, width=160.0, height=120.0)): \n    global ark_classification_roi = roi\nend\ndef ark_infer_classification():\n    local response=rosser_classify_handle.call(struct(roi_query=ark_classification_roi), 5.0)\n    local v=\"\"\n    local c=0.0\n    local error=(not response.success)\n    if not error:\n        error = length(response.reply.classif_result.labels) < 1 or length(response.reply.classif_result.confidences) < 1\n    end\n    if not error:\n        v = response.reply.classif_result.labels[0]\n        c = response.reply.classif_result.confidences[0]\n    end\n    return struct(error=ArkError(error), class_name=v, confidence=c)\nend\ndef ark_load_detection_model(model):\n    local handle = ros_service_client_factory(ARK_ROS2Namespace + \"/load_detection_model\", \"ur_ark_ros_common_msgs/srv/LoadModel\")\n    sleep(.5)\n    model_path = str_cat(\"/workspaces/isaac_ros-dev/data/models/\", model)\n    local roi = struct(x=0., y=0., width=480., height=640.)\n    handle.call(struct(model_filename=model_path, min_confidence=1.0, roi=roi))\n    handle.close()\nend  \ndef ark_set_detection_params(labels=[], min_confidence=0.3):\n    rosser_start_handle.call(struct(query=\"some_query\", model=\"\", label_list=labels, confidence=min_confidence))\nend  \n \n# returns detections as list of stamped frame_ids & poses. Blocking\ndef ark_infer_detection(): \n    local value=rosser_wait_handle.call(struct(timeout=1000))\n    local v=value.detections\n    local _poses = make_list(0, p[0,0,0,0,0,0], 50)\n    local _frames_ids = make_list(0, \"\", 50)\n    local _confidences = make_list(0, 0., 50)\n    local i=0\n    while i < v.length() and i<50: \n      local frame_name = v[i].frame_id\n      local confidence = v[i].confidence\n      local pose = ark_vec6_to_pose(v[i].pose_vec)\n      _frames_ids.append(frame_name)\n      _poses.append(pose)\n      _confidences.append(confidence)\n      #pub_transform(poses[i], frames_ids[i])\n      i = i + 1\n    end\n    return struct(error=ArkError(False), poses=_poses, frame_ids=_frames_ids, confidences=_confidences)\nend\n# set pose from 6-vector\ndef ark_vec6_to_pose(vec):\n    local pose = p[0,0,0,0,0,0]\n    assert(vec.length() >= 6)\n    local i=0\n    while i < 6: \n        pose[i] = vec[i] \n        i = i + 1\n    end\n    return pose\nend\ndef ark_set_transform(pose, frame_target, add_prefix_target=False, frame_ref=\"base\", add_prefix_ref=True):\n    local vec = [pose[0],pose[1],pose[2],pose[3],pose[4],pose[5]]\n    local data = struct(pose_vec=vec, \n        frame_ref_id=frame_ref, frame_ref_id_prepend_robot_sn=add_prefix_ref, \n        frame_id=frame_target, frame_id_prepend_robot_sn=add_prefix_target)\n    rosser_settf_handle.call(data)\n    return ArkError(False)\nend\ndef ark_get_transform(frame_target, add_prefix_target=False, frame_ref=\"base\", add_prefix_ref=True):\n    local data = struct(frame_ref_id=frame_ref, frame_ref_id_prepend_robot_sn=add_prefix_ref,\n        frame_id=frame_target, frame_id_prepend_robot_sn=add_prefix_target)\n    local res = rosser_gettf_handle.call(data)\n    local frame_poses = make_list(0, p[0,0,0,0,0,0], 50)\n    if res.error_state.error == False:\n      local v = res.pose_vec\n      frame_poses.append(p[v[0],v[1],v[2],v[3],v[4],v[5]])\n    end\n    return struct(error=ArkError(res.error_state.error), poses=frame_poses)\nend\n    \ndef ark_set_overlay(view_name):\n  pub_handle = ros_publisher_factory(topic=ARK_ROS2Namespace + \"/selected_view/selector\", msg_type=\"std_msgs/String\")\n  sleep(.2)\n  pub_handle.write(struct(data=view_name))\n  pub_handle.close()\n  return ArkError(False)\nend\n# Start of Align to Plane\n###\n# Align to plane will touch up a plane by moving the robot into contact with the table or part in several locations to determine its orientation. Afterwards the robot will orient its tool to the plane.\n# @param radius number Radius [m] of the circle within the plane will be touched up\n# @param push_force number How hard to robot pushed against the plane\n# @param n_plane_points number Number of points that the robot uses to compute the plane\n# @param max_distance number Maximum distance that the robot searches\n# @param velocity_slow number Velocity when pressing downwards\n# @param velocity_search number Velocity used when approaching the touch up point\n# @param velocity_move number Velocity used in freespace\n# @param acceleration number Acceleration of the robot\n# @param direction array 3D vector determining the direction of the TCP for touching up the plane\n###\ndef ur_align_to_plane(radius = 0.05, push_force = 20, n_plane_points = 3, max_distance = 0.25, velocity_slow = 0.001, velocity_search = 0.035, velocity_move = 0.10, acceleration = 0.1, direction = [0, 0, 1]):\n    angle = 2 * PI / n_plane_points\n    start_pos = get_target_tcp_pose()\n    retract_distance = -0.015\n    ur_move_tcp_direction(retract_distance, direction, velocity_move, acceleration, 0)\n    sleep(0.25)\n    zero_ftsensor()\n    cnt = 0\n    t_base_target = get_target_tcp_pose()\n    mean_point = [0.0, 0.0, 0.0]\n    A = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]\n    b = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    while cnt < n_plane_points:\n        new_pos = pose_trans(t_base_target, p[cos(angle * cnt) * radius, sin(angle * cnt) * radius, 0.0, 0.0, 0.0, 0.0])\n        blend_radius = norm(point_dist(get_actual_tcp_pose(), new_pos))/5\n        movel(new_pos, a = acceleration, v = velocity_move, r = blend_radius)\n        ur_move_until_force(max_distance + norm(retract_distance), direction, velocity_search, acceleration, push_force)\n        movement = normalize(direction * -1) * 0.0005\n        target_pose = pose_trans(get_actual_tcp_pose(), p[movement[0], movement[1], movement[2], 0, 0, 0])\n        movel(target_pose)\n        sleep(0.2)\n        ur_move_until_force(max_distance + norm(retract_distance), direction, velocity_slow, acceleration, push_force)\n        sleep(0.2)\n        while (not is_steady()):\n            sync()\n        end\n        poked_point = get_target_tcp_pose()\n        poked_point = pose_trans(inv(t_base_target), poked_point)\n        A[cnt, 0] = poked_point[0]\n        A[cnt, 1] = poked_point[1]\n        A[cnt, 2] = 1.0\n        b[cnt] = poked_point[2]\n        mean_point = mean_point + [poked_point[0], poked_point[1], poked_point[2]]\n        movel(new_pos, a = 0.2, v = velocity_move, r = blend_radius)\n        cnt = cnt + 1\n    end\n    mean_point = mean_point / n_plane_points\n    cnt = 0\n    while cnt < n_plane_points:\n        cntj = 0\n        while cntj < 2:\n            A[cnt, cntj] = A[cnt, cntj] - mean_point[cntj]\n            cntj = cntj + 1\n        end\n        b[cnt] = b[cnt] - mean_point[2]\n        cnt = cnt + 1\n    end\n    x1 = inv(transpose(A) * A) * transpose(A) * b\n    x = normalize([x1[0], x1[1], -1])\n    d = dot(mean_point, x)\n    dval = dot(direction, x)\n    if dval < 0:\n        x = -x\n        dval = -dval\n    end\n    eaa = [0.0, 0.0, 0.0]\n    EPSILON = 1e-10\n    if norm(dval - 1) < EPSILON:\n        # if the projection is close to 1 then the angle between the vectors are almost 0 and we cannot\n        # reliably determine the perpendicular axis.\n        # A good approximation is therefore just to set the EAA equal to 0.\n        eaa = [0.0, 0.0, 0.0]\n    else:\n        axis = cross(direction, x)\n        eaa = normalize(axis) * acos(dval)\n    end\n    t_base_target_aligned = pose_trans(t_base_target, p[0, 0, 0, eaa[0], eaa[1], eaa[2]])\n    movel(t_base_target_aligned, a = 0.2, v = velocity_move)\nend\n# End of Align to Plane\n# Start of Align Z to Nearest Axis\n###\n# Aligns the TCP Z axis to the nearest axis of the given frame\n# @param frame_id string frame_id to lookup frame\n###\ndef ur_align_z_to_nearest_axis(frame_id = \"world\"):\n    ###\n    # Given a reference frame as input this function returns a struct with the nearest\n    # pose which aligns the z-axis of the robot TCP with the z-axis of the given reference frame.\n    # The pose is in the reference of the given frame.\n    # @param frame bool frame\n    # @returns struct pose, distance, referencePose\n    ###\n    def get_aligned_z_pose(frame):\n        actualPose = get_actual_tcp_pose()\n        actualPoseInFrame = pose_trans(pose_inv(frame), actualPose)\n        # Create rotation vector and convert that to RPY representation\n        actualRotInFrame = [actualPoseInFrame[3], actualPoseInFrame[4], actualPoseInFrame[5]]\n        actRPY = rotvec2rpy(actualRotInFrame)\n        # Set RX and RY to 0 and convert back to rotation vector\n        alignedRot = rpy2rotvec([0, 0, actRPY[2]])\n        alignedRotFlipped = rpy2rotvec([PI, 0, actRPY[2]])\n        zUpPose = actualPoseInFrame\n        zUpPose[3] = alignedRot[0]\n        zUpPose[4] = alignedRot[1]\n        zUpPose[5] = alignedRot[2]\n        zUpStruct = struct(pose = zUpPose, distance=pose_dist(actualPoseInFrame, zUpPose), referencePose=frame)\n        zDownPose = actualPoseInFrame\n        zDownPose[3] = alignedRotFlipped[0]\n        zDownPose[4] = alignedRotFlipped[1]\n        zDownPose[5] = alignedRotFlipped[2]\n        zDownStruct = struct(pose = zDownPose, distance=pose_dist(actualPoseInFrame, zDownPose), referencePose=frame)\n        # Return the solution which is closer to the current robot pose\n        if (zDownStruct.distance > zUpStruct.distance):\n            return zUpStruct\n        else:\n            return zDownStruct\n        end\n    end\n    frame = get_pose(frame_id)\n    # Rotate the given frame so that Z can be align to X-Y-Z respectively \n    rotZtoX = rpy2rotvec([0,0.5*PI,0])\n    rotZtoY = rpy2rotvec([0.5*PI,0,0])\n    rotZtoZ = rpy2rotvec([0,0,0])\n    # Get aligned poses for each of the rotated frames\n    structAlignedToX = get_aligned_z_pose(pose_trans(frame, p[0,0,0,rotZtoX[0],rotZtoX[1],rotZtoX[2]]))\n    structAlignedToY = get_aligned_z_pose(pose_trans(frame, p[0,0,0,rotZtoY[0],rotZtoY[1],rotZtoY[2]]))\n    structAlignedToZ = get_aligned_z_pose(pose_trans(frame, p[0,0,0,rotZtoZ[0],rotZtoZ[1],rotZtoZ[2]]))\n    # Find the nearest alignement\n    structAligned = structAlignedToZ\n    if(structAligned.distance > structAlignedToX.distance):\n        structAligned = structAlignedToX    \n    end\n    if(structAligned.distance > structAlignedToY.distance):\n        structAligned = structAlignedToY    \n    end\n    # Move the robot to the aligned pose\n    movel(pose_trans(get_actual_tcp_pose(), p[0,0,0.00001,0,0,0]), v = 0.1)\n    movel(pose_trans(structAligned.referencePose, structAligned.pose ), v = 0.1)\nend\n# End of Align Z to Nearest Axis\n# Start of Center to Object\n###\n# Centers to an object by touching the externals of it. It works well for fixtured or heavy parts.\n# @param push_force number Force the robot uses to determine if a contact has been achieved\n# @param velocity_move number Velocity in freespace\n# @param velocity_search number First move is used then search\n# @param acc_move number Acceleration in freespace\n# @param max_radius_search number Maximum search radius\n# @param num_fingers number Number of fingers that the gripper has\n###\ndef ur_center_to_object(push_force = 10, velocity_move = 0.10, velocity_search = 0.01, acc_move = 0.2, max_radius_search = 0.05, num_fingers = 3):\n    def compute_circle_center(p_list):\n        # Compute the circle center by circular regression\n        # Source: https://math.stackexchange.com/questions/2898295/how-to-quickly-fit-a-circle-by-given-random-arc-points\n        itr = 0\n        x = 0\n        y = 1\n    \n        m1 = [[0,0,0],[0,0,0],[0,0,0]]\n        m2 = [[0,0],[0,0],[0,0]]\n        m3 = [[0],[0],[0]]\n    \n        while(itr < get_list_length(p_list)):\n            p = p_list[itr]\n    \n            if(p_list[itr] == p[0,0,0,0,0,0]):\n                break\n            end\n    \n            m1[0,0] = m1[0,0] + (p[x]*p[x])\n            m1[0,1] = m1[0,1] + (p[x]*p[y])\n            m1[0,2] = m1[0,2] + (p[x])\n    \n            m1[1,0] = m1[1,0] + (p[x]*p[y])\n            m1[1,1] = m1[1,1] + (p[y]*p[y])\n            m1[1,2] = m1[1,2] + (p[y])\n    \n            m1[2,0] = m1[2,0] + (p[x])\n            m1[2,1] = m1[2,1] + (p[y])\n    \n            m2[0,0] = m2[0,0] + (pow(p[x], 3))\n            m2[0,1] = m2[0,1] + (p[x] * pow(p[y], 2))\n    \n            m2[1,0] = m2[1,0] + (pow(p[y], 3))\n            m2[1,1] = m2[1,1] + (pow(p[x], 2) * p[y])\n    \n            m2[2,0] = m2[2,0] + (pow(p[x], 2))\n            m2[2,1] = m2[2,1] + (pow(p[y], 2))\n    \n            itr = itr +1\n        end\n    \n        if(itr < 2):\n            return p[0,0,0,0,0,0]\n        elif(itr > get_list_length(p_list)):\n            return p[0,0,0,0,0,0]\n        end\n    \n        m1[0,0] = 2 * m1[0,0]\n        m1[0,1] = 2 * m1[0,1]\n        m1[1,0] = 2 * m1[1,0]\n        m1[1,1] = 2 * m1[1,1]\n        m1[2,0] = 2 * m1[2,0]\n        m1[2,1] = 2 * m1[2,1]\n        m1[2,2] = itr\n        m3[0,0] = m2[0,0] + m2[0,1]\n        m3[1,0] = m2[1,0] + m2[1,1]\n        m3[2,0] = m2[2,0] + m2[2,1]\n    \n        center = inv(m1) * m3\n    \n        return p[center[0,0], center[1,0],0,0,0,0]\n    end\n    \n    def sanity_checked_move(p_org, p_new, max_diff, acc, vel):\n        if (pose_dist(p_org, p_new) > max_diff):\n            movel(p_org, a = acc, v = vel)\n            popup(\"New pose is too far away from original. Returning to original\", title = \"Failed\", warning = False, error = True, blocking = True)\n        else:\n            movel(p_new, a = acc, v = vel)\n        end\n    end\n    # Start by zeroing the FT sensor\n    sleep(0.25)\n    zero_ftsensor()\n    p_start = get_actual_tcp_pose()\n    p0 = p[0,0,0,0,0,0]\n    DIR_X = [1, 0, 0]\n    if (num_fingers == 2):\n        dir_list = [DIR_X, -DIR_X, DIR_X, -DIR_X]\n        start_offset = [p[0,0,0,0,0,0], p[0,0,0,0,0,0], p[0,0,0,0,0,0.35], p[0,0,0,0,0,0.35]]\n        p_list = [p0, p0, p0, p0]\n    elif (num_fingers == 3):\n        DIR_P1 = DIR_X\n        DIR_P2 = [-1 / 2, sqrt(3.0) / 2.0, 0]\n        DIR_P3 = [-1 / 2, -sqrt(3.0) / 2.0, 0]\n        dir_list = [DIR_P1, DIR_P2, DIR_P3, DIR_P1, DIR_P2, DIR_P3]\n        start_offset = [p[0,0,0,0,0,0], p[0,0,0,0,0,0], p[0,0,0,0,0,0], p[0,0,0,0,0,0.35], p[0,0,0,0,0,0.35], p[0,0,0,0,0,0.35]]\n        p_list = [p0, p0, p0, p0, p0, p0]\n    else:\n        popup(\"Number of fingers not supported\")\n        halt\n    end\n    # Loop through directions\n    it = 0\n    dir_list_size = size(dir_list)\n    dir_list_length = dir_list_size[0]\n    while(it < dir_list_length):\n        # Move to starting position if more than 3 positions is stored then calculate a new starting position\n        if(it < 3):\n            movel(pose_trans(p_start, start_offset[it]), a = acc_move, v = velocity_move)\n        else:\n            p_start_temp = pose_trans(pose_trans(p_start, compute_circle_center(p_list)), start_offset[it])\n            p_start_w_offset = pose_trans(p_start, start_offset[it])\n            sanity_checked_move(p_start_w_offset, p_start_temp, max_radius_search, acc_move, velocity_move)\n        end\n        p_start_temp = get_actual_tcp_pose()\n        # Move into contact and store contact point\n        sleep(0.1)\n        contact_point = ur_move_until_force(distance = max_radius_search, direction = [dir_list[it, 0], dir_list[it, 1], dir_list[it, 2]], velocity = velocity_search, acceleration = acc_move, stop_force = push_force)\n        \n        dir = [dir_list[it, 0], dir_list[it, 1], dir_list[it, 2]]\n        dir = normalize(dir) * 0.05\n        contact_point = pose_trans(contact_point, p[dir[0], dir[1], dir[2], 0, 0, 0])\n        p_list[it] = pose_trans(pose_inv(p_start), contact_point)\n        # Move out of contact\n        movel(p_start_temp, a = acc_move, v = velocity_move)\n        it = it + 1\n    end\n    # Find circle center based on n stored  points\n    center_offset_xy = compute_circle_center(p_list)\n    p_center = pose_trans(p_start, center_offset_xy)\n    \n    # Move the robot to the center if it can\n    sanity_checked_move(p_start, p_center, max_radius_search, acc_move, velocity_move)\nend\n# End of Center to Object\n# Start of Move Into Contact\n###\n# Moves the robot into contact in the TCP direction set\n# @param force number Force that determines when a contact has been achieved\n# @param velocity number Velocity of the robot\n# @param acceleration number Acceleration of the robot\n# @param max_distance number Maximum distance that the robot searches\n# @param velocity_search number velocity_search\n# @param retract number Retract distance after a contact has been found\n# @param move_tcp_dir array TCP direction (3D vector)\n# @param zero_ft_on_start bool Determines if the force-torque sensor should be zeroed on start\n###\ndef ur_move_into_contact(force = 10, velocity = 0.05, acceleration = 0.1, max_distance = 0.25, retract = 0.0, move_tcp_dir = [0, 0, 1], zero_ft_on_start = True):\n    # Zero the force torque sensor\n    if (zero_ft_on_start):\n        sleep(0.25)\n        zero_ftsensor()\n    end\n    # Move the robot\n    ur_move_until_force(max_distance, move_tcp_dir, velocity, acceleration, force)\n    # If a retract distance is set, move the robot back to that position\n    if (retract != 0):\n        # Compute position offset from TCP direction and retract distance\n        position = normalize(move_tcp_dir) * retract\n        movel(pose_trans(get_actual_tcp_pose(), p[position[0], position[1], position[2], 0, 0, 0]))\n    end\nend\n# End of Move Into Contact\n# Start of Retract\n###\n# Retract in the TCP direction set\n# @param distance number Retraction distance\n# @param direction array TCP direction to move in (3D vector)\n# @param acceleration number Acceleration used by the robot\n# @param velocity number Velocity used by the robot\n###\ndef ur_retract(distance = -0.1, direction = [0, 0, 1], acceleration = 0.4, velocity = 0.1):\n    movement = normalize(direction) * distance\n    movel(pose_trans(get_actual_tcp_pose(), p[movement[0], movement[1], movement[2], 0, 0, 0]), a = acceleration, v = velocity)\nend\n# End of Retract","nodeIDList":[]}},"program":{"id":"3","programContent":{"children":[{"children":[],"contributedNode":{"children":[],"type":"ur-modules","version":"0.0.1","allowsChildren":true,"lockChildren":false},"guid":"37f821b9-74b9-7c12-53a9-d51c2dfa6973","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},{"children":[],"contributedNode":{"type":"ur-functions","version":"0.0.1","allowsChildren":true,"lockChildren":false},"guid":"2c74904f-2bd6-3553-14fa-03a65607b813","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},{"children":[],"contributedNode":{"type":"ur-before-start","version":"0.0.1","allowsChildren":true},"guid":"4b5303e9-b76b-11f0-03db-5834ac13f018","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},{"children":[],"contributedNode":{"type":"ur-configuration","version":"0.0.1","allowsChildren":true,"parameters":{}},"guid":"3dd8e6f2-f19e-d3ab-a5a1-de87cdacc378","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},{"children":[],"contributedNode":{"type":"ur-status","version":"0.0.1","allowsChildren":true,"parameters":{}},"guid":"ceb5f253-7392-a2d4-c609-bd37ce75308e","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},{"children":[{"children":[],"contributedNode":{"type":"ur-script","version":"0.0.1","parameters":{"name":"init ark","expression":"ark_init()","valid":true}},"guid":"15e7cfb1-970f-77cc-bff3-7760ded8e13c","parentId":"41bf9e35-a783-a7fa-2ade-6b37bd07c91e","programLabel":"init ark"},{"children":[{"children":[],"contributedNode":{"version":"0.0.3","type":"ur-move-to","allowsChildren":false,"parameters":{"moveType":"moveJ","variable":{"entity":{"name":"wp_detect","reference":false,"type":"$$Variable","valueType":"waypoint","declaredByID":"cd8dff1a-5e4b-d785-afad-0bbf964e7d70","suppressed":false},"selectedType":"VALUE","value":"wp_detect"},"waypoint":{"frame":"base","tcp":{"name":"Tool_flange","id":"67b595b4-9a65-e62a-c12c-e957e52f288e"},"qNear":{"base":2.807131767272949,"shoulder":-1.7333785496153773,"elbow":1.7744372526751917,"wrist1":-1.234749899511673,"wrist2":-1.6969206968890589,"wrist3":-0.32232886949648076},"pose":{"x":{"entity":{"value":0.39789895592985575,"unit":"m"},"selectedType":"VALUE","value":0.39789895592985575},"y":{"entity":{"value":-0.010244933265989855,"unit":"m"},"selectedType":"VALUE","value":-0.010244933265989855},"z":{"entity":{"value":0.4361710852618056,"unit":"m"},"selectedType":"VALUE","value":0.4361710852618056},"rx":{"entity":{"value":2.013784446665926,"unit":"rad"},"selectedType":"VALUE","value":2.013784446665926},"ry":{"entity":{"value":-1.985281421491668,"unit":"rad"},"selectedType":"VALUE","value":-1.985281421491668},"rz":{"entity":{"value":-0.3989621803039409,"unit":"rad"},"selectedType":"VALUE","value":-0.3989621803039409}}},"advanced":{"speed":{"speed":{"entity":{"value":1.04719755,"unit":"rad/s"},"selectedType":"VALUE","value":1.04719755},"acceleration":{"entity":{"value":1.3962633999999998,"unit":"rad/s^2"},"selectedType":"VALUE","value":1.3962633999999998}},"blend":{"enabled":false},"transform":{"transform":false}}},"isSuppressed":false},"guid":"cd8dff1a-5e4b-d785-afad-0bbf964e7d70","parentId":"1aa16302-2188-1ae3-8504-a575faa811a9","programLabel":[{"type":"primary","value":"wp_detect"},{"type":"secondary","value":"Joint"},{"type":"secondary","value":"base"},{"type":"secondary","value":"Tool_flange"},{"type":"secondary","value":"S: 60.00 /s"},{"type":"secondary","value":"A: 80.00 /s"}]},{"children":[],"contributedNode":{"type":"ur-script","version":"0.0.1","parameters":{"name":"classify","expression":"local roi_query = struct(x=240.0, y=210.0, width=160.0, height=50.0)\nark_set_classification_params(roi=roi_query)\n\nclass_result = ark_infer_classification()\nwhile class_result.error.error:\n    textmsg(\"Classification timed out. Retrying\")\n    class_result = ark_infer_classification()\nend\n    \nglobal class_name = class_result[1]\nglobal class_score = class_result[2]","valid":true}},"guid":"10e4b135-97a6-efa4-2b0a-ecff957d5484","parentId":"1aa16302-2188-1ae3-8504-a575faa811a9","programLabel":"classify"},{"children":[{"children":[],"contributedNode":{"version":"0.0.3","type":"ur-move-to","allowsChildren":false,"parameters":{"moveType":"moveJ","variable":{"entity":{"name":"wp_state_0","reference":false,"type":"$$Variable","valueType":"waypoint","declaredByID":"0a14cedb-60da-f07f-1c05-1402f36b84d1","suppressed":false},"selectedType":"VALUE","value":"wp_state_0"},"waypoint":{"frame":"base","tcp":{"name":"Tool_flange","id":"67b595b4-9a65-e62a-c12c-e957e52f288e"},"qNear":{"base":3.0986742973327637,"shoulder":-1.7410012684264125,"elbow":1.8595159689532679,"wrist1":-1.4670251321843644,"wrist2":-1.6885135809527796,"wrist3":-0.39222604433168584},"pose":{"x":{"entity":{"value":0.3974997271560458,"unit":"m"},"selectedType":"VALUE","value":0.3974997271560458},"y":{"entity":{"value":0.10501791996918078,"unit":"m"},"selectedType":"VALUE","value":0.10501791996918078},"z":{"entity":{"value":0.4155175874722272,"unit":"m"},"selectedType":"VALUE","value":0.4155175874722272},"rx":{"entity":{"value":2.3982958717531213,"unit":"rad"},"selectedType":"VALUE","value":2.3982958717531213},"ry":{"entity":{"value":-1.6488527678152112,"unit":"rad"},"selectedType":"VALUE","value":-1.6488527678152112},"rz":{"entity":{"value":-0.17349381049845802,"unit":"rad"},"selectedType":"VALUE","value":-0.17349381049845802}}},"advanced":{"speed":{"speed":{"entity":{"value":1.04719755,"unit":"rad/s"},"selectedType":"VALUE","value":1.04719755},"acceleration":{"entity":{"value":1.3962633999999998,"unit":"rad/s^2"},"selectedType":"VALUE","value":1.3962633999999998}},"blend":{"enabled":false},"transform":{"transform":false}}},"isSuppressed":false},"guid":"0a14cedb-60da-f07f-1c05-1402f36b84d1","parentId":"e1ab6717-b6f1-ec7f-0b03-b4b5df133a5c","programLabel":[{"type":"primary","value":"wp_state_0"},{"type":"secondary","value":"Joint"},{"type":"secondary","value":"base"},{"type":"secondary","value":"Tool_flange"},{"type":"secondary","value":"S: 60.00 /s"},{"type":"secondary","value":"A: 80.00 /s"}]},{"children":[],"contributedNode":{"type":"ur-wait","version":"0.0.2","parameters":{"type":"time","time":{"entity":{"value":0.5,"unit":"s"},"selectedType":"VALUE","value":"0.5"}}},"guid":"f58b8937-83b9-4986-e415-ab3505545b43","parentId":"e1ab6717-b6f1-ec7f-0b03-b4b5df133a5c","programLabel":[{"type":"secondary","value":"0.50 s"}]}],"contributedNode":{"type":"ur-if","version":"0.0.1","allowsChildren":true,"parameters":{"expression":"class_name == \"state_0\""}},"guid":"e1ab6717-b6f1-ec7f-0b03-b4b5df133a5c","parentId":"1aa16302-2188-1ae3-8504-a575faa811a9","programLabel":[{"type":"secondary","value":"class_name == \"state_0\""}]},{"children":[{"children":[],"contributedNode":{"version":"0.0.3","type":"ur-move-to","allowsChildren":false,"parameters":{"moveType":"moveJ","variable":{"entity":{"name":"wp_state_1","reference":false,"type":"$$Variable","valueType":"waypoint","declaredByID":"da5ca913-473e-fecc-1b0f-906ce81ed1e5","suppressed":false},"selectedType":"VALUE","value":"wp_state_1"},"waypoint":{"frame":"base","tcp":{"name":"Tool_flange","id":"67b595b4-9a65-e62a-c12c-e957e52f288e"},"qNear":{"base":2.887101173400879,"shoulder":-1.740758558312887,"elbow":1.85807973543276,"wrist1":-1.5624373716166993,"wrist2":-1.6885359922992151,"wrist3":-0.39218122163881475},"pose":{"x":{"entity":{"value":0.4215964442684466,"unit":"m"},"selectedType":"VALUE","value":0.4215964442684466},"y":{"entity":{"value":0.016466024610239736,"unit":"m"},"selectedType":"VALUE","value":0.016466024610239736},"z":{"entity":{"value":0.4238247004236728,"unit":"m"},"selectedType":"VALUE","value":0.4238247004236728},"rx":{"entity":{"value":2.2515513535778715,"unit":"rad"},"selectedType":"VALUE","value":2.2515513535778715},"ry":{"entity":{"value":-1.9382394488974608,"unit":"rad"},"selectedType":"VALUE","value":-1.9382394488974608},"rz":{"entity":{"value":-0.08232317781271536,"unit":"rad"},"selectedType":"VALUE","value":-0.08232317781271536}}},"advanced":{"speed":{"speed":{"entity":{"value":1.04719755,"unit":"rad/s"},"selectedType":"VALUE","value":1.04719755},"acceleration":{"entity":{"value":1.3962633999999998,"unit":"rad/s^2"},"selectedType":"VALUE","value":1.3962633999999998}},"blend":{"enabled":false},"transform":{"transform":false}}},"isSuppressed":false},"guid":"da5ca913-473e-fecc-1b0f-906ce81ed1e5","parentId":"c03f5608-dfe9-5298-09d9-ac1762308163","programLabel":[{"type":"primary","value":"wp_state_1"},{"type":"secondary","value":"Joint"},{"type":"secondary","value":"base"},{"type":"secondary","value":"Tool_flange"},{"type":"secondary","value":"S: 60.00 /s"},{"type":"secondary","value":"A: 80.00 /s"}]},{"children":[],"contributedNode":{"type":"ur-wait","version":"0.0.2","parameters":{"type":"time","time":{"entity":{"value":0.5,"unit":"s"},"selectedType":"VALUE","value":"0.5"}}},"guid":"227d44ef-516f-1744-c765-ec8e8042b129","parentId":"c03f5608-dfe9-5298-09d9-ac1762308163","programLabel":[{"type":"secondary","value":"0.50 s"}]}],"contributedNode":{"type":"ur-elseif","version":"0.0.1","allowsChildren":true,"parameters":{"expression":"class_name == \"state_1\""}},"guid":"c03f5608-dfe9-5298-09d9-ac1762308163","parentId":"1aa16302-2188-1ae3-8504-a575faa811a9","programLabel":[{"type":"secondary","value":"class_name == \"state_1\""}]}],"contributedNode":{"type":"ur-loop","version":"0.0.1","allowsChildren":true,"parameters":{"type":"always","expression":"","xtimes":1}},"guid":"1aa16302-2188-1ae3-8504-a575faa811a9","parentId":"41bf9e35-a783-a7fa-2ade-6b37bd07c91e","programLabel":[{"type":"secondary","value":"Always"}]}],"contributedNode":{"type":"ur-code","version":"0.0.1","allowsChildren":true,"lockChildren":false,"parameters":{"loopForever":false}},"guid":"41bf9e35-a783-a7fa-2ade-6b37bd07c91e","parentId":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"}],"contributedNode":{"children":[{"children":[],"type":"ur-modules","version":"0.0.1","allowsChildren":true,"lockChildren":false},{"type":"ur-functions","version":"0.0.1","allowsChildren":true,"lockChildren":false},{"type":"ur-before-start","version":"0.0.1","allowsChildren":true},{"type":"ur-configuration","version":"0.0.1","allowsChildren":true,"parameters":{}},{"type":"ur-status","version":"0.0.1","allowsChildren":true,"parameters":{}},{"type":"ur-code","version":"0.0.1","allowsChildren":true,"lockChildren":false,"parameters":{"loopForever":false}}],"type":"ur-program","version":"0.0.1","allowsChildren":true,"lockChildren":true,"parameters":{"name":"Default program"}},"guid":"3c887ef5-74c8-4ef9-e516-423cde12e6ab"},"programInformation":{"name":"ark_example_classify","description":"","createdDate":1724799103784,"lastSavedDate":null,"lastModifiedDate":null,"programState":"FINAL","functionsBlockShown":false},"urscript":{"script":"global wp_detect = struct(p=p[0.39789895592985575, -0.010244933265989855, 0.4361710852618056, 2.013784446665926, -1.985281421491668, -0.3989621803039409], frame=\"base\", q=[2.807131767272949, -1.7333785496153773, 1.7744372526751917, -1.234749899511673, -1.6969206968890589, -0.32232886949648076])\nglobal wp_state_0 = struct(p=p[0.3974997271560458, 0.10501791996918078, 0.4155175874722272, 2.3982958717531213, -1.6488527678152112, -0.17349381049845802], frame=\"base\", q=[3.0986742973327637, -1.7410012684264125, 1.8595159689532679, -1.4670251321843644, -1.6885135809527796, -0.39222604433168584])\nglobal wp_state_1 = struct(p=p[0.4215964442684466, 0.016466024610239736, 0.4238247004236728, 2.2515513535778715, -1.9382394488974608, -0.08232317781271536], frame=\"base\", q=[2.887101173400879, -1.740758558312887, 1.85807973543276, -1.5624373716166993, -1.6885359922992151, -0.39218122163881475])\n$ 1 \"Default program\"\n$ 2 \"Modules\"\n$ 3 \"\"\n$ 4 \"Before Start\"\n$ 5 \"Configuration\"\n$ 6 \"Status\"\n$ 7 \"Looping: Disabled\"\n$ 8 \"init ark\"\nark_init()\n$ 9 \"Always\"\nwhile (True):\n  $ 10 \"wp_detectJointbaseTool_flangeS: 60.00 /sA: 80.00 /s\"\n  set_tcp(p[0, 0, 0, 0, 0, 0], \"Tool_flange\")\n  movej(get_inverse_kin(convert_pose(wp_detect.p, wp_detect.frame, \"base\"), qnear=wp_detect.q), a=1.3962633999999998, v=1.04719755)\n  $ 11 \"classify\"\n  local roi_query = struct(x=240.0, y=210.0, width=160.0, height=50.0)\n  ark_set_classification_params(roi=roi_query)\n  class_result = ark_infer_classification()\n  while class_result.error.error:\n      textmsg(\"Classification timed out. Retrying\")\n      class_result = ark_infer_classification()\n  end\n      \n  global class_name = class_result[1]\n  global class_score = class_result[2]\n  $ 12 \"class_name == 'state_0'\"\n  if (class_name == \"state_0\"):\n    $ 13 \"wp_state_0JointbaseTool_flangeS: 60.00 /sA: 80.00 /s\"\n    set_tcp(p[0, 0, 0, 0, 0, 0], \"Tool_flange\")\n    movej(get_inverse_kin(convert_pose(wp_state_0.p, wp_state_0.frame, \"base\"), qnear=wp_state_0.q), a=1.3962633999999998, v=1.04719755)\n    $ 14 \"0.50 s\"\n    sleep(0.5)\n  $ 15 \"class_name == 'state_1'\"\n  elif (class_name == \"state_1\"):\n    $ 16 \"wp_state_1JointbaseTool_flangeS: 60.00 /sA: 80.00 /s\"\n    set_tcp(p[0, 0, 0, 0, 0, 0], \"Tool_flange\")\n    movej(get_inverse_kin(convert_pose(wp_state_1.p, wp_state_1.frame, \"base\"), qnear=wp_state_1.q), a=1.3962633999999998, v=1.04719755)\n    $ 17 \"0.50 s\"\n    sleep(0.5)\n  end\nend","nodeIDList":["00000000-0000-0000-0000-000000000000","3c887ef5-74c8-4ef9-e516-423cde12e6ab","37f821b9-74b9-7c12-53a9-d51c2dfa6973","2c74904f-2bd6-3553-14fa-03a65607b813","4b5303e9-b76b-11f0-03db-5834ac13f018","3dd8e6f2-f19e-d3ab-a5a1-de87cdacc378","ceb5f253-7392-a2d4-c609-bd37ce75308e","41bf9e35-a783-a7fa-2ade-6b37bd07c91e","15e7cfb1-970f-77cc-bff3-7760ded8e13c","1aa16302-2188-1ae3-8504-a575faa811a9","cd8dff1a-5e4b-d785-afad-0bbf964e7d70","10e4b135-97a6-efa4-2b0a-ecff957d5484","e1ab6717-b6f1-ec7f-0b03-b4b5df133a5c","0a14cedb-60da-f07f-1c05-1402f36b84d1","f58b8937-83b9-4986-e415-ab3505545b43","c03f5608-dfe9-5298-09d9-ac1762308163","da5ca913-473e-fecc-1b0f-906ce81ed1e5","227d44ef-516f-1744-c765-ec8e8042b129"]}}}